# imports
import pygame
from math import sqrt, floor
from random import choice


# some variables
SCREEN_WIDTH = 720
SCREEN_HEIGHT = 720
FPS = 60
BACKGROUND_COLOR = (255, 255, 255)
BALLS_COLOR = (0, 0, 0)
BALLS_SIZE = 30
NUMBER_OF_BALLS = 20
BALLS_SPEED = 5
STOP_TIME = 1100
PINK = (211, 23, 142)
PINK_LAUNCH_TIME = 100
PINK_SPEED = BALLS_SPEED / 10


# ball class
class Ball:

    def __init__(self, x, y, x_speed, y_speed, radius, color):
        self.x = x
        self.y = y
        self.x_speed = x_speed
        self.y_speed = y_speed
        self.radius = radius
        self.color = color

    def draw(self):
        pygame.draw.circle(screen, self.color, (int(self.x), int(self.y)), self.radius)


def collision_check(ball1, ball2):
    # finds distance between two centres of the balls and sum of their radiates
    center_distance = sqrt((ball1.x - ball2.x) ** 2 + (ball1.y - ball2.y) ** 2)
    two_radiates_sum = ball1.radius + ball2.radius
    # returns True when collision and False otherwise
    if center_distance <= two_radiates_sum:
        return True
    else:
        return False


def collision(ball1, ball2):
    # collision calculation
    # 1
    # unit normal vector
    un = [ball1.x - ball2.x, ball1.y - ball2.y]
    # unit tangent vector
    ut = [-un[1], un[0]]
    # 2
    # velocity vector for ball1
    v1 = [ball1.x_speed, ball1.y_speed]
    # velocity vector for ball2
    v2 = [ball2.x_speed, ball2.y_speed]
    # 3
    # vectors to plain numbers
    if un[0] * un[0] + un[1] * un[1] == 0:
        v1n = 0
    else:
        v1n = (v1[0] * un[0] + v1[1] * un[1]) / (un[0] * un[0] + un[1] * un[1])
    if ut[0] * ut[0] + ut[1] * ut[1] == 0:
        v1t = 0
    else:
        v1t = (v1[0] * ut[0] + v1[1] * ut[1]) / (ut[0] * ut[0] + ut[1] * ut[1])
    if un[0] * un[0] + un[1] * un[1] == 0:
        v2n = 0
    else:
        v2n = (v2[0] * un[0] + v2[1] * un[1]) / (un[0] * un[0] + un[1] * un[1])
    if ut[0] * ut[0] + ut[1] * ut[1] == 0:
        v2t = 0
    else:
        v2t = (v2[0] * ut[0] + v2[1] * ut[1]) / (ut[0] * ut[0] + ut[1] * ut[1])
    # 4
    # new tangent velocities
    # there is no friction so this step is not necessary
    # 5
    # new normal velocities
    # there are masses in original formulas, so they are left ones as placeholders
    # but because masses are the same it means v1n, v2n = v2n, v1n
    v1n, v2n = (v1n * (1 - 1) + 2 * 1 * v2n) / (1 + 1), (v2n * (1 - 1) + 2 * 1 * v1n) / (1 + 1)
    # 6
    # scalar values to vectors for ball1
    v1n = [v1n * un[0], v1n * un[1]]
    v1t = [v1t * ut[0], v1t * ut[1]]
    # scalar values to vectors for ball2
    v2n = [v2n * un[0], v2n * un[1]]
    v2t = [v2t * ut[0], v2t * ut[1]]
    # 7
    # new velocity vectors
    v1[0] = v1n[0] + v1t[0]
    v1[1] = v1n[1] + v1t[1]
    v2[0] = v2n[0] + v2t[0]
    v2[1] = v2n[1] + v2t[1]
    # assigment to balls
    ball1.x_speed = v1[0]
    ball1.y_speed = v1[1]
    ball2.x_speed = v2[0]
    ball2.y_speed = v2[1]
    # end of collision calculation

    # moving ball1 and ball2 a litte so they dont stuck into each other
    # point of collision
    cx = (ball1.x + ball2.x) / 2
    cy = (ball1.y + ball2.y) / 2
    # distance from collision point to ball1 centre (a bit smaller than radius)
    d = sqrt((ball1.x - cx) ** 2 + (ball1.y - cy) ** 2)
    # distance between point of the collision to ball1 center point in both axes divided by d
    if d == 0:
        x_speed = 0
        dy = 0
    else:
        x_speed = (ball1.x - cx) / d
        dy = (ball1.y - cy) / d
    # ball1 move to point of collision + radius time ex or ey
    ball1.x = cx + x_speed * ball1.radius
    ball1.y = cy + dy * ball1.radius
    # ball2 move in opposite direction
    x_speed = -x_speed
    dy = -dy
    ball2.x = cx + x_speed * ball2.radius
    ball2.y = cy + dy * ball2.radius
    return ball1, ball2


def move(ball):
    # moving ball
    ball.x = ball.x + ball.x_speed
    ball.y = ball.y + ball.y_speed
    # checking for wall collision
    if ball.x >= SCREEN_WIDTH - BALLS_SIZE:
        ball.x_speed = -ball.x_speed
        ball.x = SCREEN_WIDTH - BALLS_SIZE - 1
    if ball.x <= BALLS_SIZE:
        ball.x_speed = -ball.x_speed
        ball.x = BALLS_SIZE + 1
    if ball.y >= SCREEN_HEIGHT - BALLS_SIZE:
        ball.y_speed = -ball.y_speed
        ball.y = SCREEN_HEIGHT - BALLS_SIZE - 1
    if ball.y <= BALLS_SIZE:
        ball.y_speed = -ball.y_speed
        ball.y = BALLS_SIZE + 1
    return ball


# writes prompt and creates screen and clock
print('\nHello! This program allows to play with perfect elastic ball collisions.')
print('\nAll collision formulas based on article by Chad Berchek "2-Dimensional Elastic Collisions without Trigonometry".')
print('http://www.vobarian.com/collisions/\n')
# On one time unit every ball travels thought as many pixels as their speed says
# It is possible to add masses to this simulation, there is placeholder for it in formulas
pygame.init()
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
clock = pygame.time.Clock()

# creating circles
balls = []
count = 0
while count < NUMBER_OF_BALLS:
    for i in range(floor(SCREEN_HEIGHT / (2.5 * BALLS_SIZE))):
        for j in range(floor(SCREEN_WIDTH / (2.5 * BALLS_SIZE))):
            balls.append(Ball(2.5 * BALLS_SIZE + j * 2.5 * BALLS_SIZE, 2.5 * BALLS_SIZE + i * 2.5 * BALLS_SIZE, choice([-BALLS_SPEED, BALLS_SPEED]), choice([-BALLS_SPEED, BALLS_SPEED]), BALLS_SIZE, BALLS_COLOR))
            count += 1
            if count == NUMBER_OF_BALLS:
                break
        if count == NUMBER_OF_BALLS:
            break

# main loop
time = 0
time_since_last_pink_collision = 0
pink_collision_times = []
while True:
    time += 1
    time_since_last_pink_collision += 1
    if time == STOP_TIME:
        print('Time since pink ball appeared:', time - PINK_LAUNCH_TIME)
        print('Number of collisions with pink ball:', len(pink_collision_times))
        print('Average time between collision with pink ball:', sum(pink_collision_times) / len(pink_collision_times))
        exit(0)
    if time == PINK_LAUNCH_TIME:
        balls.append(Ball(SCREEN_WIDTH - BALLS_SIZE, SCREEN_HEIGHT - BALLS_SIZE, -PINK_SPEED, -PINK_SPEED, BALLS_SIZE, PINK))
        time_since_last_pink_collision = 0
    # checks if user wants to close the screen
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            print('Time since pink ball appeared:', time - PINK_LAUNCH_TIME)
            print('Number of collisions with pink ball:', len(pink_collision_times))
            print('Average time between collision with pink ball:', sum(pink_collision_times) / len(pink_collision_times))
            exit(0)
    # moves balls and checks if any circle hit the wall
    for element in balls:
        move(element)
    # checks for collisions between balls
    for ball1_index in range(0, len(balls)):
        for ball2_index in range(ball1_index + 1, len(balls)):
            if collision_check(balls[ball1_index], balls[ball2_index]):
                if balls[ball1_index].color == PINK or balls[ball2_index].color == PINK:
                    pink_collision_times.append(time_since_last_pink_collision)
                    time_since_last_pink_collision = 0
                balls[ball1_index], balls[ball2_index] = collision(balls[ball1_index], balls[ball2_index])
                # breaks the second for loop, so the balls wont stuck into each other
                break
    # drawing stuff
    screen.fill(BACKGROUND_COLOR)
    for element in balls:
        element.draw()
    pygame.display.flip()
    clock.tick(FPS)
