
# tworzy wlasna macierz
def create_own_matrix():
    print('Wpisz macierz sasiedztwa wiersz po wierszu:')
    adjacency_matrix = []
    first_row = input().split()
    adjacency_matrix.append(first_row)
    for i in range(len(first_row) - 1):
        adjacency_matrix.append(input().split())
    print('adjacency matrix:', adjacency_matrix)
    return adjacency_matrix


# robi z macierzy liste nastepnikow
def to_consequents_list(adjacency_matrix):
    consequents_list = []
    for i in range(len(adjacency_matrix)):
        consequents_list.append([])
        for j in range(len(adjacency_matrix)):
            if adjacency_matrix[i][j] == 1:
                consequents_list[i].append(j)
    print('consequents list:', consequents_list)
    return consequents_list


# robi z macierzy liste krawedzi
def to_edge_table(adjacency_matrix):
    edge_table = []
    adjacency_matrix_copy = adjacency_matrix.copy()
    for i in range(len(adjacency_matrix)):
        for j in range(len(adjacency_matrix)):
            if adjacency_matrix_copy[i][j] == 1:
                edge_table.append([i, j])
                adjacency_matrix_copy[j][i] = 0
    print('edge table:', edge_table)
    return edge_table


# wywoływana w inndej funkcji
def dfs_adjacency_matrix(adjacency_matrix_copy, to_look, node):
    if node in to_look:
        print(node)
        to_look.remove(node)
    for position_number in range(len(adjacency_matrix_copy)):
        if adjacency_matrix_copy[node][position_number] == 1:
            adjacency_matrix_copy[node][position_number] = 0
            dfs_adjacency_matrix(adjacency_matrix_copy, to_look, position_number)


# printuje dfs z macierzy sąsiedztwa
def print_dfs_adjacency_matrix(adjacency_matrix):
    to_look = list(range(0, len(adjacency_matrix)))
    print('dfs adjecency matrix:')
    adjacency_matrix_copy = adjacency_matrix.copy()
    while to_look:
        dfs_adjacency_matrix(adjacency_matrix_copy, to_look, to_look[0])


# wywolywana w innej funkcji
def bfs_adjacency_matrix(visited, stack, adjacency_matrix_copy, node, to_look):
    visited.append(node)
    stack.append(node)
    if node in to_look:
        to_look.remove(node)
    while stack:
        current = stack.pop(0)
        print(current)
        if current in to_look:
            to_look.remove(current)
        for position in range(len(adjacency_matrix)):
            if adjacency_matrix_copy[current][position] == 1 and position not in visited:
                stack.append(position)
                visited.append(position)


# printuje bfs z macierzy sasiedztwa
def print_bfs_adjacency_matrix(adjacency_matrix):
    visited = []
    to_look = list(range(0, len(adjacency_matrix)))
    adjacency_matrix_copy = adjacency_matrix.copy()
    print('bfs adjacency matrix:')
    while to_look:
        bfs_adjacency_matrix(visited, [], adjacency_matrix_copy, to_look[0], to_look)


# wywolywana w innej funkcji
def dfs_consequents_list(visited, consequents_list, node, to_look):
    if node not in visited:
        print(node)
        visited.append(node)
        if node in to_look:
            to_look.remove(node)
        for consequent in consequents_list[node]:
            dfs_consequents_list(visited, consequents_list, consequent, to_look)


# printuje dfs z listy nastepnikow
def print_dfs_consequents_list(consequents_list):
    visited = []
    to_look = list(range(0, len(consequents_list)))
    print('dfs consequents list:')
    while to_look:
        dfs_consequents_list(visited, consequents_list, to_look[0], to_look)


# wywolywana w innej funkcji
def bfs_consequents_list(visited, stack, consequents_list, node, to_look):
    visited.append(node)
    stack.append(node)
    if node in to_look:
        to_look.remove(node)
    while stack:
        current = stack.pop(0)
        print(current)
        if current in to_look:
            to_look.remove(current)
        for consequent in consequents_list[current]:
            if consequent not in visited:
                stack.append(consequent)
                visited.append(consequent)


# printuje bfs z listy nastepnikow
def print_bfs_consequents_list(consequents_list):
    visited = []
    to_look = list(range(0, len(consequents_list)))
    print('bfs consequents list:')
    while to_look:
        bfs_consequents_list(visited, [], consequents_list, to_look[0], to_look)


# wywolywana w innej funkcji
def dfs_edge_table(edge_table, node, to_look):
    if node in to_look:
        print(node)
        to_look.remove(node)
    for edge in edge_table:
        if edge[0] == node:
            dfs_edge_table(edge_table, edge[1], to_look)


# printuje dfs z listy krawedzi
def print_dfs_edge_table(edge_table, number_of_nodes):
    to_look = list(range(0, number_of_nodes))
    print('dfs edge table:')
    while to_look:
        dfs_edge_table(edge_table, to_look[0], to_look)


# wywolywana w innej funkcji
def bfs_edge_table(visited, stack, edge_table, node, to_look):
    visited.append(node)
    stack.append(node)
    if node in to_look:
        to_look.remove(node)
    while stack:
        current = stack.pop(0)
        print(current)
        if current in to_look:
            to_look.remove(current)
        for edge in edge_table:
            if edge[0] == current and edge[1] not in visited:
                stack.append(edge[1])
                visited.append(edge[1])


# printuje bfs z listy krawedzi
def print_bfs_edge_table(edge_table, number_of_nodes):
    visited = []
    to_look = list(range(0, number_of_nodes))
    print('bfs edge table:')
    while to_look:
        bfs_edge_table(visited, [], edge_table, to_look[0], to_look)


# drivers code
adjacency_matrix = [[0, 1, 0, 0, 0, 0, 0, 0],
                    [1, 0, 1, 1, 1, 1, 0, 0],
                    [0, 1, 0, 1, 0, 0, 0, 0],
                    [0, 1, 1, 0, 0, 0, 1, 0],
                    [0, 1, 0, 0, 0, 1, 1, 1],
                    [0, 1, 0, 0, 1, 1, 0, 1],
                    [0, 0, 0, 1, 1, 0, 0, 0],
                    [0, 0, 0, 0, 1, 1, 0, 0]]

# adjacency_matrix = [[0, 1, 0, 1, 0, 1],
#                     [1, 0, 1, 0, 0, 1],
#                     [0, 1, 0, 1, 0, 0],
#                     [1, 0, 1, 0, 1, 0],
#                     [0, 0, 0, 1, 0, 1],
#                     [1, 1, 0, 0, 1, 0]]

print(adjacency_matrix)
edge_table = to_edge_table(adjacency_matrix)
consequents_list = to_consequents_list(adjacency_matrix)

print_dfs_adjacency_matrix(adjacency_matrix)
print_dfs_consequents_list(consequents_list)
print_dfs_edge_table(edge_table, len(adjacency_matrix))  # moze wywalic recurssion error

print_bfs_adjacency_matrix(adjacency_matrix)
print_bfs_consequents_list(consequents_list)
print_bfs_edge_table(edge_table, len(adjacency_matrix))
